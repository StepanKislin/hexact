<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HexAct - –î–µ—Ç–µ–∫—Ü–∏—è –±–æ–ª—Ç–æ–≤ –∏ –≥–∞–µ–∫</title>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8fafc;
            color: #1e293b;
            min-height: 100vh;
        }
        .container { max-width: 1800px; margin: 0 auto; }
        h1 { font-weight: 700; margin-bottom: 10px; font-size: 28px; }
        .subtitle { color: #64748b; margin-bottom: 15px; }

        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .stat-card {
            background: white;
            padding: 12px 20px;
            border-radius: 10px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.08);
            min-width: 140px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            margin-top: 4px;
        }
        .stat-total { color: #1d4ed8; }
        .stat-warning { color: #ca8a04; }
        .stat-reject { color: #dc2626; }

        .tabs {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin: 15px auto 20px;
            flex-wrap: wrap;
        }
        .tab-btn {
            padding: 12px 24px;
            border: none;
            background: #e2e8f0;
            font-weight: 600;
            border-radius: 10px;
            cursor: pointer;
            color: #475569;
            min-width: 140px;
        }
        .tab-btn.active { background: #3b82f6; color: white; }

        .main-layout {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            margin: 15px 0;
        }
        .video-panel, .canvas-panel, .current-detections {
            border-radius: 14px;
            overflow: hidden;
            box-shadow: 0 6px 16px rgba(0,0,0,0.1);
            background: #000;
            flex-shrink: 0;
        }
        .video-panel, .canvas-panel {
            width: 560px;
            height: 420px;
        }
        #video, #canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .current-detections {
            width: 320px;
            background: white;
            padding: 20px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }
        .current-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: #1e293b;
            font-size: 18px;
            text-align: center;
        }
        #current-list {
            flex: 1;
            overflow-y: auto;
        }
        .current-item {
            padding: 10px 0;
            border-bottom: 1px solid #f1f5f9;
        }
        .current-item:last-child { border-bottom: none; }
        .current-type { font-weight: 600; font-size: 15px; }
        .hex-bolt { color: #1d4ed8; }
        .phillips { color: #059669; }
        .hex-nut { color: #b45309; }
        .current-conf { color: #64748b; font-size: 14px; text-align: right; }

        .info-box {
            background: white;
            padding: 18px;
            border-radius: 12px;
            margin: 15px auto;
            max-width: 1500px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.06);
        }

        #status, #warning {
            margin: 12px auto;
            padding: 12px 20px;
            border-radius: 10px;
            max-width: 1500px;
        }
        #status { background: #dbeafe; color: #1e40af; }
        #warning { display: none; }
        .warning-low { background-color: #fff3cd; color: #856404; }
        .warning-reject { background-color: #fee2e2; color: #b91c1c; }

        .history-section {
            margin-top: 25px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.06);
            max-width: 1500px;
            margin-left: auto;
            margin-right: auto;
        }
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        #clear-history, #print-stats {
            padding: 8px 16px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        #print-stats {
            background: #3b82f6;
            margin-left: 8px;
        }
        #detections-list {
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            padding-right: 10px;
        }
        .detection-item {
            padding: 8px 0;
            border-bottom: 1px solid #f1f5f9;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
        }
        .footer { margin-top: 20px; color: #94a3b8; font-size: 13px; }
    </style>
</head>
<body>
<div class="container">
    <h1>üîç HexAct - –î–µ—Ç–µ–∫—Ü–∏—è –±–æ–ª—Ç–æ–≤ –∏ –≥–∞–µ–∫</h1>
    <div class="subtitle">–í–∏–¥–µ–æ ‚Üí Canvas ‚Üí –¢–µ–∫—É—â–∏–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è (–≤—Å–µ –≤ –ª–∏–Ω–∏—é)</div>

    <!-- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ -->
    <div class="stats">
        <div class="stat-card">
            <div>–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ</div>
            <div class="stat-value stat-total" id="correct-count">0</div>
        </div>
        <div class="stat-card">
            <div>–í—Å–µ–≥–æ</div>
            <div class="stat-value" id="total-count">0</div>
        </div>
        <div class="stat-card">
            <div>‚ö†Ô∏è –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π</div>
            <div class="stat-value stat-warning" id="warning-count">0</div>
        </div>
        <div class="stat-card">
            <div>‚ùå –ë—Ä–∞–∫–∞</div>
            <div class="stat-value stat-reject" id="reject-count">0</div>
        </div>
    </div>

    <div class="tabs">
        <button class="tab-btn active" data-tab="bolts">–ë–æ–ª—Ç—ã</button>
        <button class="tab-btn" data-tab="nuts">–ì–∞–π–∫–∏</button>
    </div>

    <div class="main-layout">
        <div class="video-panel">
            <video id="video" autoplay muted playsinline></video>
        </div>
        <div class="canvas-panel">
            <canvas id="canvas" width="560" height="420"></canvas>
        </div>
        <div class="current-detections">
            <div class="current-title">–ù–∞–π–¥–µ–Ω–æ —Å–µ–π—á–∞—Å</div>
            <div id="current-list">
                <div style="color:#94a3b8; font-style:italic; text-align:center;">–ù–∏—á–µ–≥–æ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ</div>
            </div>
        </div>
    </div>

    <div class="info-box" id="instructions">
        –ü–æ–ª–æ–∂–∏—Ç–µ –±–æ–ª—Ç –≥–æ–ª–æ–≤–∫–æ–π –≤–≤–µ—Ä—Ö. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —à–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω—ã–µ –≥–æ–ª–æ–≤–∫–∏ –∏ –∫—Ä—É–≥–ª—ã–µ —Å –∫—Ä–µ—Å—Ç–æ–º (Phillips).
    </div>

    <div id="status">–ó–∞–≥—Ä—É–∑–∫–∞ OpenCV.js‚Ä¶</div>
    <div id="warning"></div>

    <div class="history-section">
        <div class="history-header">
            <div class="history-title">–ò—Å—Ç–æ—Ä–∏—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–π (<span id="count">0</span>)</div>
            <div>
                <button id="print-stats">üñ®Ô∏è –ü–µ—á–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏</button>
                <button id="clear-history">–û—á–∏—Å—Ç–∏—Ç—å</button>
            </div>
        </div>
        <div id="detections-list"></div>
    </div>

    <div class="footer">
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è OpenCV.js ‚Ä¢ –î–ª—è —Ä–∞–±–æ—Ç—ã —Ç—Ä–µ–±—É–µ—Ç—Å—è –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ
    </div>
</div>

<!-- ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–±—Ä–∞–Ω—ã –ø—Ä–æ–±–µ–ª—ã –≤ –∫–æ–Ω—Ü–µ URL -->
<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
    let video, canvas, ctx, warningDiv, statusDiv, instructionsDiv;
    let currentListDiv, detectionsList, countSpan;
    let totalCountEl, warningCountEl, rejectCountEl, correctCountEl;
    let isStreamActive = false;
    let currentTab = 'bolts';
    let detectionsHistory = [];

    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ç–∏–ø–∞–º
    const stats = {
        bolts: { total: 0, correct: 0, warning: 0, reject: 0 },
        nuts: { total: 0, correct: 0, warning: 0, reject: 0 }
    };

    let trackedObjects = [];
    let nextId = 1;
    const FORGET_AFTER_MS = 2500;
    const MIN_FRAMES_TO_REPORT = 3;
    const SIMILARITY_DIST = 35;

    // === UI ===
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentTab = btn.dataset.tab;
            updateInstructions();
        });
    });

    document.getElementById('clear-history').addEventListener('click', () => {
        detectionsHistory = [];
        trackedObjects = [];
        stats.bolts = { total: 0, correct: 0, warning: 0, reject: 0 };
        stats.nuts = { total: 0, correct: 0, warning: 0, reject: 0 };
        updateDetectionsList();
        updateStats();
        updateCharts();
    });

    // === –î–û–ë–ê–í–õ–ï–ù–û: –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–µ—á–∞—Ç–∏ ===
    document.getElementById('print-stats').addEventListener('click', printStatistics);

    function printStatistics() {
        const bolts = stats.bolts;
        const nuts = stats.nuts;
        const totalAll = bolts.total + nuts.total;
        const correctAll = bolts.correct + nuts.correct;
        const warningAll = bolts.warning + nuts.warning;
        const rejectAll = bolts.reject + nuts.reject;

        const correctPct = totalAll ? Math.round((correctAll / totalAll) * 100) : 0;
        const warnPct = totalAll ? Math.round((warningAll / totalAll) * 100) : 0;
        const rejectPct = totalAll ? Math.round((rejectAll / totalAll) * 100) : 0;

        const printWin = window.open('', '_blank');
        printWin.document.write(`
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <title>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–µ—Ç–µ–∫—Ü–∏–∏ –±–æ–ª—Ç–æ–≤ –∏ –≥–∞–µ–∫</title>
                <style>
                    body {
                        font-family: Arial, sans-serif;
                        padding: 20px;
                        color: #1e293b;
                        background: white;
                    }
                    h1 { text-align: center; margin-bottom: 25px; color: #1e40af; }
                    .summary {
                        display: flex;
                        justify-content: space-around;
                        flex-wrap: wrap;
                        gap: 20px;
                        margin: 20px 0;
                    }
                    .card {
                        text-align: center;
                        padding: 15px;
                        border: 1px solid #ddd;
                        border-radius: 10px;
                        min-width: 130px;
                    }
                    .value { font-size: 24px; font-weight: bold; margin-top: 8px; }
                    .ok { color: #10b981; }
                    .warn { color: #f59e0b; }
                    .bad { color: #ef4444; }
                    .chart {
                        width: 200px;
                        height: 20px;
                        background: #f1f5f9;
                        border-radius: 4px;
                        margin: 8px auto;
                        overflow: hidden;
                    }
                    .bar-ok { height: 100%; background: #10b981; }
                    .bar-warn { height: 100%; background: #f59e0b; }
                    .bar-bad { height: 100%; background: #ef4444; }
                    .footer {
                        margin-top: 30px;
                        text-align: center;
                        color: #64748b;
                        font-size: 14px;
                    }
                    @media print {
                        body { padding: 0; }
                    }
                </style>
            </head>
            <body>
                <h1>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–µ—Ç–µ–∫—Ü–∏–∏ –±–æ–ª—Ç–æ–≤ –∏ –≥–∞–µ–∫</h1>

                <div class="summary">
                    <div class="card">
                        <div>–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ</div>
                        <div class="value ok">${correctAll} (${correctPct}%)</div>
                    </div>
                    <div class="card">
                        <div>–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è</div>
                        <div class="value warn">${warningAll} (${warnPct}%)</div>
                    </div>
                    <div class="card">
                        <div>–ë—Ä–∞–∫</div>
                        <div class="value bad">${rejectAll} (${rejectPct}%)</div>
                    </div>
                    <div class="card">
                        <div>–í—Å–µ–≥–æ</div>
                        <div class="value">${totalAll}</div>
                    </div>
                </div>

                <div style="text-align:center; margin:25px 0;">
                    <div>‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ</div>
                    <div class="chart"><div class="bar-ok" style="width:${correctPct}%"></div></div>
                    <div>‚ö†Ô∏è –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è</div>
                    <div class="chart"><div class="bar-warn" style="width:${warnPct}%"></div></div>
                    <div>‚ùå –ë—Ä–∞–∫</div>
                    <div class="chart"><div class="bar-bad" style="width:${rejectPct}%"></div></div>
                </div>

                <div class="footer">
                    –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ: ${new Date().toLocaleString('ru-RU')}<br>
                    –°–∏—Å—Ç–µ–º–∞ –¥–µ—Ç–µ–∫—Ü–∏–∏ –∫—Ä–µ–ø–µ–∂–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ OpenCV.js
                </div>

                <script>
                    window.onload = () => {
                        window.print();
                        setTimeout(() => window.close(), 1000);
                    };

`);
printWin.document.close();
}

function updateInstructions() {
if (currentTab === 'bolts') {
instructionsDiv.textContent = '–ü–æ–ª–æ–∂–∏—Ç–µ –±–æ–ª—Ç –≥–æ–ª–æ–≤–∫–æ–π –≤–≤–µ—Ä—Ö. –¢–æ–ª—å–∫–æ —à–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫ –∏–ª–∏ Phillips.';
} else {
instructionsDiv.textContent = '–ü–æ–ª–æ–∂–∏—Ç–µ –≥–∞–π–∫—É —Å–≤–µ—Ä—Ö—É. –¢–æ–ª—å–∫–æ —à–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫.';
}
}

function getTrackedObject(detection) {
const center = {
x: detection.rect.x + detection.rect.width / 2,
y: detection.rect.y + detection.rect.height / 2
};
const size = (detection.rect.width + detection.rect.height) / 2;

for (let obj of trackedObjects) {
const dx = obj.center.x - center.x;
const dy = obj.center.y - center.y;
const dist = Math.sqrt(dx*dx + dy*dy);
const sizeDiff = Math.abs(obj.size - size);
if (dist < SIMILARITY_DIST && sizeDiff < SIMILARITY_DIST * 0.4 && obj.type === detection.type && obj.subtype === detection.subtype) {
obj.lastSeen = Date.now();
obj.center = center;
obj.size = size;
obj.frameCount++;
return obj;
}
}

const newObj = {
id: nextId++,
type: detection.type,
subtype: detection.subtype,
center: center,
size: size,
lastSeen: Date.now(),
frameCount: 1,
reported: false
};
trackedObjects.push(newObj);

const now = Date.now();
trackedObjects = trackedObjects.filter(obj => now - obj.lastSeen < FORGET_AFTER_MS);

return newObj;
}

function addToHistoryIfNeeded(detection) {
const obj = getTrackedObject(detection);
if (!obj || obj.reported || obj.frameCount < MIN_FRAMES_TO_REPORT) return;

const currentStats = stats[currentTab];
let category = 'ok';
let displayType = '';
let isCorrect = false;

if (detection.subtype === 'hex') {
displayType = currentTab === 'bolts' ? '–®–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫ (–±–æ–ª—Ç)' : '–®–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫ (–≥–∞–π–∫–∞)';
isCorrect = true;
currentStats.correct++;
} else if (detection.subtype === 'phillips') {
if (currentTab === 'bolts') {
displayType = '–ö—Ä–µ—Å—Ç (Phillips)';
isCorrect = true;
currentStats.correct++;
} else {
// –ì–∞–π–∫–∏ –Ω–µ –±—ã–≤–∞—é—Ç Phillips ‚Üí –±—Ä–∞–∫
displayType = '‚ùå Phillips (–Ω–µ –≥–∞–π–∫–∞)';
category = 'reject';
currentStats.reject++;
}
} else if (['pentagon', 'heptagon', 'octagon', 'incomplete_hex', 'circle_no_cross'].includes(detection.subtype)) {
category = 'reject';
currentStats.reject++;
const names = {
'pentagon': '–ø—è—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫',
'heptagon': '—Å–µ–º–∏—É–≥–æ–ª—å–Ω–∏–∫',
'octagon': '–≤–æ—Å—å–º–∏—É–≥–æ–ª—å–Ω–∏–∫',
'incomplete_hex': '–Ω–µ–∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–π —à–µ—Å—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫',
'circle_no_cross': '–∫—Ä—É–≥ –±–µ–∑ –∫—Ä–µ—Å—Ç–∞'
};
displayType = '–ë—Ä–∞–∫: ' + names[detection.subtype];
} else {
category = 'warning';
currentStats.warning++;
displayType = '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Ñ–æ—Ä–º–∞';
}

currentStats.total++;

const now = new Date();
const newItem = {
id: obj.id,
type: currentTab,
subtype: detection.subtype,
displayType,
confidence: detection.confidence,
timestamp: now,
rect: detection.rect,
category,
isCorrect
};
detectionsHistory.unshift(newItem);
obj.reported = true;

updateDetectionsList();
updateStats();
updateCharts();
}

function updateStats() {
const totalAll = stats.bolts.total + stats.nuts.total;
const correctAll = stats.bolts.correct + stats.nuts.correct;
const warningAll = stats.bolts.warning + stats.nuts.warning;
const rejectAll = stats.bolts.reject + stats.nuts.reject;

correctCountEl.textContent = correctAll;
totalCountEl.textContent = totalAll;
warningCountEl.textContent = warningAll;
rejectCountEl.textContent = rejectAll;
}

function updateCharts() {
const container = document.getElementById('charts-container');
if (!container) return;

const bolts = stats.bolts;
const nuts = stats.nuts;

function getPercent(part, total) {
return total === 0 ? 0 : Math.round((part / total) * 100);
}

const boltsCorrectPct = getPercent(bolts.correct, bolts.total);
const boltsRejectPct = getPercent(bolts.reject, bolts.total);
const boltsWarnPct = getPercent(bolts.warning, bolts.total);

const nutsCorrectPct = getPercent(nuts.correct, nuts.total);
const nutsRejectPct = getPercent(nuts.reject, nuts.total);
const nutsWarnPct = getPercent(nuts.warning, nuts.total);

container.innerHTML = `
<div style="display:flex;gap:30px;flex-wrap:wrap;justify-content:center;margin-top:20px;">
    <div style="text-align:center;">
        <div style="font-weight:600;">–ë–æ–ª—Ç—ã (${bolts.total})</div>
        <div style="width:200px;height:20px;background:#e2e8f0;border-radius:4px;margin:5px auto;overflow:hidden;">
            <div style="width:${boltsCorrectPct}%;height:100%;background:#10b981;"></div>
        </div>
        <div>‚úÖ ${boltsCorrectPct}%</div>
        <div style="width:200px;height:20px;background:#e2e8f0;border-radius:4px;margin:5px auto;overflow:hidden;">
            <div style="width:${boltsWarnPct}%;height:100%;background:#f59e0b;"></div>
        </div>
        <div>‚ö†Ô∏è ${boltsWarnPct}%</div>
        <div style="width:200px;height:20px;background:#e2e8f0;border-radius:4px;margin:5px auto;overflow:hidden;">
            <div style="width:${boltsRejectPct}%;height:100%;background:#ef4444;"></div>
        </div>
        <div>‚ùå ${boltsRejectPct}%</div>
    </div>
    <div style="text-align:center;">
        <div style="font-weight:600;">–ì–∞–π–∫–∏ (${nuts.total})</div>
        <div style="width:200px;height:20px;background:#e2e8f0;border-radius:4px;margin:5px auto;overflow:hidden;">
            <div style="width:${nutsCorrectPct}%;height:100%;background:#10b981;"></div>
        </div>
        <div>‚úÖ ${nutsCorrectPct}%</div>
        <div style="width:200px;height:20px;background:#e2e8f0;border-radius:4px;margin:5px auto;overflow:hidden;">
            <div style="width:${nutsWarnPct}%;height:100%;background:#f59e0b;"></div>
        </div>
        <div>‚ö†Ô∏è ${nutsWarnPct}%</div>
        <div style="width:200px;height:20px;background:#e2e8f0;border-radius:4px;margin:5px auto;overflow:hidden;">
            <div style="width:${nutsRejectPct}%;height:100%;background:#ef4444;"></div>
        </div>
        <div>‚ùå ${nutsRejectPct}%</div>
    </div>
</div>
`;
}

function updateDetectionsList() {
countSpan.textContent = detectionsHistory.length;
detectionsList.innerHTML = '';

detectionsHistory.forEach(item => {
const div = document.createElement('div');
div.className = 'detection-item';

const timeStr = item.timestamp.toLocaleTimeString();
div.innerHTML = `<span>${item.displayType}</span><span>${Math.round(item.confidence)}% ‚Ä¢ ${timeStr}</span>`;
detectionsList.appendChild(div);
});
}

function updateCurrentList(detections) {
if (detections.length === 0) {
currentListDiv.innerHTML = '<div style="color:#94a3b8; font-style:italic; text-align:center;">–ù–∏—á–µ–≥–æ –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ</div>';
return;
}

let html = '';
detections.forEach(det => {
let typeClass = '', typeText = '';
if (det.subtype === 'hex') {
typeText = currentTab === 'bolts' ? '–®–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫ (–±–æ–ª—Ç)' : '–®–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫ (–≥–∞–π–∫–∞)';
typeClass = currentTab === 'bolts' ? 'hex-bolt' : 'hex-nut';
} else if (det.subtype === 'phillips') {
typeText = '–ö—Ä–µ—Å—Ç (Phillips)';
typeClass = 'phillips';
} else if (['pentagon', 'heptagon', 'octagon', 'incomplete_hex', 'circle_no_cross'].includes(det.subtype)) {
const names = {
'pentagon': '–ü—è—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫',
'heptagon': '–°–µ–º–∏—É–≥–æ–ª—å–Ω–∏–∫',
'octagon': '–í–æ—Å—å–º–∏—É–≥–æ–ª—å–Ω–∏–∫',
'incomplete_hex': '–ù–µ–∑–∞–≤–µ—Ä—à. —à–µ—Å—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫',
'circle_no_cross': '–ö—Ä—É–≥ –±–µ–∑ –∫—Ä–µ—Å—Ç–∞'
};
typeText = '‚ùå ' + names[det.subtype];
typeClass = 'stat-reject';
} else {
typeText = '‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Ñ–æ—Ä–º–∞';
typeClass = 'stat-warning';
}

html += `
<div class="current-item">
    <div class="current-type ${typeClass}">${typeText}</div>
    <div class="current-conf">${Math.round(det.confidence)}%</div>
</div>
`;
});
currentListDiv.innerHTML = html;
}

// === –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ===
window.addEventListener('load', () => {
video = document.getElementById("video");
canvas = document.getElementById("canvas");
ctx = canvas.getContext("2d");
warningDiv = document.getElementById("warning");
statusDiv = document.getElementById("status");
instructionsDiv = document.getElementById("instructions");
currentListDiv = document.getElementById("current-list");
detectionsList = document.getElementById("detections-list");
countSpan = document.getElementById("count");
totalCountEl = document.getElementById("total-count");
warningCountEl = document.getElementById("warning-count");
rejectCountEl = document.getElementById("reject-count");
correctCountEl = document.getElementById("correct-count");

// –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –¥–∏–∞–≥—Ä–∞–º–º
const historySection = document.querySelector('.history-section');
const chartsContainer = document.createElement('div');
chartsContainer.id = 'charts-container';
historySection.parentNode.insertBefore(chartsContainer, historySection.nextSibling);

const checkOpenCV = () => {
if (typeof cv !== 'undefined') {
statusDiv.textContent = "‚úÖ OpenCV.js –≥–æ—Ç–æ–≤. –ó–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä—ã‚Ä¶";
startCamera();
} else {
setTimeout(checkOpenCV, 300);
}
};
checkOpenCV();
});

function startCamera() {
if (!navigator.mediaDevices?.getUserMedia) {
statusDiv.textContent = "‚ùå –ö–∞–º–µ—Ä–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è";
statusDiv.className = "warning-reject";
return;
}

const constraints = { video: { width: 560, height: 420 } };
navigator.mediaDevices.getUserMedia(constraints)
.then(stream => {
video.srcObject = stream;
isStreamActive = true;
statusDiv.textContent = "üé• –ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞. –ü–æ–ª–æ–∂–∏—Ç–µ –∫—Ä–µ–ø—ë–∂.";
requestAnimationFrame(mainLoop);
})
.catch(err => {
statusDiv.textContent = "‚ùå –î–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ –∑–∞–ø—Ä–µ—â—ë–Ω";
statusDiv.className = "warning-reject";
});
}

// === –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ===
function pointToLineDistance(px, py, x1, y1, x2, y2) {
const A = px - x1;
const B = py - y1;
const C = x2 - x1;
const D = y2 - y1;
const dot = A * C + B * D;
const lenSq = C * C + D * D;
let param = lenSq !== 0 ? dot / lenSq : -1;
let xx = param < 0 ? x1 : (param > 1 ? x2 : x1 + param * C);
let yy = param < 0 ? y1 : (param > 1 ? y2 : y1 + param * D);
const dx = px - xx;
const dy = py - yy;
return Math.sqrt(dx * dx + dy * dy);
}

function getAngleBetweenLines(l1, l2) {
const a1 = Math.atan2(l1.y2 - l1.y1, l1.x2 - l1.x1) * 180 / Math.PI;
const a2 = Math.atan2(l2.y2 - l2.y1, l2.x2 - l2.x1) * 180 / Math.PI;
let diff = Math.abs(a1 - a2);
return diff > 180 ? 360 - diff : diff;
}

// === –î–ï–¢–ï–ö–¶–ò–Ø –§–û–†–ú ===
function detectAllShapes(gray) {
const binary = new cv.Mat();
cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
cv.medianBlur(binary, binary, 5);

const contours = new cv.MatVector();
const hierarchy = new cv.Mat();
cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

const results = [];

for (let i = 0; i < contours.size(); i++) {
const contour = contours.get(i);
const area = cv.contourArea(contour, false);
if (area < 800 || area > 20000) continue;

const rect = cv.boundingRect(contour);
const aspect = rect.width / rect.height;
if (aspect < 0.6 || aspect > 1.6) continue;

const perimeter = cv.arcLength(contour, true);
if (perimeter === 0) continue;

const epsilon = 0.02 * perimeter;
const approx = new cv.Mat();
cv.approxPolyDP(contour, approx, epsilon, true);

const vertices = approx.rows;
let subtype = 'unknown';
let confidence = 60;

if (vertices >= 4 && vertices <= 8) {
if (vertices === 5) {
subtype = 'pentagon';
confidence = 80;
} else if (vertices === 6) {
const { isRegular, conf } = isRegularHexagonFromApprox(approx, rect);
if (isRegular) {
subtype = 'hex';
confidence = conf;
} else {
subtype = 'incomplete_hex';
confidence = 75;
}
} else if (vertices === 7) {
subtype = 'heptagon';
confidence = 80;
} else if (vertices === 8) {
subtype = 'octagon';
confidence = 80;
}
} else if (vertices < 4) {
const circularity = 4 * Math.PI * area / (perimeter * perimeter);
if (circularity > 0.7) {
subtype = 'possible_circle';
confidence = 70;
} else {
subtype = 'unknown';
confidence = 50;
}
}

results.push({ rect, confidence, type: 'shape', subtype });
approx.delete();
}

binary.delete();
contours.delete();
hierarchy.delete();

return results;
}

function isRegularHexagonFromApprox(approx, rect) {
const points = [];
for (let i = 0; i < 6; i++) {
points.push({ x: approx.data32S[i * 2], y: approx.data32S[i * 2 + 1] });
}

let cx = 0, cy = 0;
points.forEach(p => { cx += p.x; cy += p.y; });
cx /= 6; cy /= 6;

const radii = points.map(p => Math.sqrt((p.x - cx)**2 + (p.y - cy)**2));
const avgRadius = radii.reduce((a, b) => a + b, 0) / 6;
const radiusStd = Math.sqrt(radii.reduce((sum, r) => sum + (r - avgRadius)**2, 0) / 6);

const angles = [];
for (let i = 0; i < 6; i++) {
const p1 = points[i];
const p2 = points[(i + 1) % 6];
const v1x = p1.x - cx, v1y = p1.y - cy;
const v2x = p2.x - cx, v2y = p2.y - cy;
const dot = v1x * v2x + v1y * v2y;
const det = v1x * v2y - v1y * v2x;
let angle = Math.atan2(det, dot) * 180 / Math.PI;
if (angle < 0) angle += 360;
angles.push(angle);
}
const avgAngle = angles.reduce((a, b) => a + b, 0) / 6;
const angleStd = Math.sqrt(angles.reduce((sum, a) => sum + (a - avgAngle)**2, 0) / 6);

if (radiusStd / avgRadius <= 0.15 && angleStd <= 15) {
let conf = 100;
if (radiusStd / avgRadius > 0.1) conf = 95;
if (angleStd > 10) conf = Math.min(conf, 95);
return { isRegular: true, conf };
}
return { isRegular: false, conf: 0 };
}

function detectPhillipsAndCircles(gray) {
const blurred = new cv.Mat();
cv.GaussianBlur(gray, blurred, new cv.Size(7, 7), 0);

const circles = new cv.Mat();
cv.HoughCircles(
blurred,
circles,
cv.HOUGH_GRADIENT,
1,
gray.rows / 5,
120,
35,
25,
80
);

const results = [];

if (circles.cols > 0) {
for (let i = 0; i < circles.cols; i++) {
const x = circles.data32F[i * 3];
const y = circles.data32F[i * 3 + 1];
const r = circles.data32F[i * 3 + 2];
if (r < 20 || r > 75) continue;

const roiSize = Math.round(r * 2.2);
const roiX = Math.max(0, Math.round(x - roiSize / 2));
const roiY = Math.max(0, Math.round(y - roiSize / 2));
const roiW = Math.min(roiSize, gray.cols - roiX);
const roiH = Math.min(roiSize, gray.rows - roiY);

const roi = gray.roi(new cv.Rect(roiX, roiY, roiW, roiH));
const edges = new cv.Mat();
cv.Canny(roi, edges, 60, 160, 3, false);

const lines = new cv.Mat();
cv.HoughLinesP(edges, lines, 1, Math.PI / 180, 40, 30, 12);

let hasCross = false;
if (lines.rows > 0) {
let validLines = [];
for (let j = 0; j < lines.rows; j++) {
const x1 = lines.data32S[j * 4];
const y1 = lines.data32S[j * 4 + 1];
const x2 = lines.data32S[j * 4 + 2];
const y2 = lines.data32S[j * 4 + 3];
const len = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);
if (len < r * 0.6) continue;
const gx1 = x1 + roiX;
const gy1 = y1 + roiY;
const gx2 = x2 + roiX;
const gy2 = y2 + roiY;
const dist = pointToLineDistance(x, y, gx1, gy1, gx2, gy2);
if (dist < r * 0.2) {
validLines.push({ x1: gx1, y1: gy1, x2: gx2, y2: gy2 });
}
}

for (let a = 0; a < validLines.length; a++) {
for (let b = a + 1; b < validLines.length; b++) {
const angle = getAngleBetweenLines(validLines[a], validLines[b]);
if (angle >= 85 && angle <= 95) {
hasCross = true;
break;
}
}
if (hasCross) break;
}
}

if (hasCross) {
results.push({
rect: { x: x - r, y: y - r, width: r * 2, height: r * 2 },
confidence: 95,
type: 'phillips',
subtype: 'phillips'
});
} else {
results.push({
rect: { x: x - r, y: y - r, width: r * 2, height: r * 2 },
confidence: 80,
type: 'circle',
subtype: 'circle_no_cross'
});
}

edges.delete();
roi.delete();
lines.delete();
}
}

circles.delete();
blurred.delete();

return results;
}

// === –û–°–ù–û–í–ù–û–ô –¶–ò–ö–õ ===
function mainLoop() {
if (!isStreamActive) return;

ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

try {
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
const src = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
src.data.set(imageData.data);

const gray = new cv.Mat();
cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

let currentDetections = [];

if (currentTab === 'bolts') {
const shapes = detectAllShapes(gray);
const phillipsAndCircles = detectPhillipsAndCircles(gray);
currentDetections = [...shapes, ...phillipsAndCircles];
} else if (currentTab === 'nuts') {
const shapes = detectAllShapes(gray);
// –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —à–µ—Å—Ç–∏–≥—Ä–∞–Ω–Ω–∏–∫–∏ (–≥–∞–π–∫–∏ –Ω–µ –±—ã–≤–∞—é—Ç –∫—Ä—É–≥–ª—ã–º–∏ –∏–ª–∏ Phillips)
currentDetections = shapes.filter(d => d.subtype === 'hex');
}

currentDetections = currentDetections.filter(d => d.confidence >= 60);
currentDetections.sort((a, b) => b.confidence - a.confidence);

warningDiv.style.display = "none";
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

currentDetections.forEach(det => {
const r = det.rect;
let color = "#00ff00";
if (['pentagon', 'heptagon', 'octagon', 'incomplete_hex', 'circle_no_cross'].includes(det.subtype)) {
color = "#ff0000";
} else if (det.subtype === 'unknown' || det.confidence < 75) {
color = "#ffaa00";
}

ctx.strokeStyle = color;
ctx.lineWidth = 2;
ctx.strokeRect(r.x, r.y, r.width, r.height);

ctx.fillStyle = "white";
ctx.font = "14px Arial";
ctx.textAlign = "left";

let label = '';
if (det.subtype === 'hex') {
label = currentTab === 'bolts' ? '–ë–æ–ª—Ç' : '–ì–∞–π–∫–∞';
} else if (det.subtype === 'phillips') {
label = '–ö—Ä–µ—Å—Ç';
} else if (det.subtype === 'circle_no_cross') {
label = '–ö—Ä—É–≥ (–±—Ä–∞–∫)';
} else if (det.subtype === 'pentagon') {
label = '5-—É–≥–æ–ª (–±—Ä–∞–∫)';
} else if (det.subtype === 'heptagon') {
label = '7-—É–≥–æ–ª (–±—Ä–∞–∫)';
} else if (det.subtype === 'octagon') {
label = '8-—É–≥–æ–ª (–±—Ä–∞–∫)';
} else if (det.subtype === 'incomplete_hex') {
label = '–ù–µ–∑–∞–≤.6 (–±—Ä–∞–∫)';
} else {
label = '???';
}

ctx.fillText(`${label} ${Math.round(det.confidence)}%`, r.x + 4, r.y - 6);
});

updateCurrentList(currentDetections);

currentDetections.forEach(det => {
addToHistoryIfNeeded(det);
});

src.delete();
gray.delete();

} catch (e) {
console.error("–û—à–∏–±–∫–∞:", e);
statusDiv.textContent = "‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–∞–¥—Ä–∞";
statusDiv.className = "warning-low";
}

requestAnimationFrame(mainLoop);
}
</script>

</body>
</html>